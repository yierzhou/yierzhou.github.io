+++
date = '2025-07-04T10:27:46+08:00'
draft = false
title = 'First'
+++

# 程序执行的过程（*）

程序被执行后就被称为一个进程，一个进程可以被划分为很多区域，这门课我们只需要理解以下的四个区就可以了。

1. **代码区与常量区**：进程按照代码区的代码执行，真正的常量也存储在这里，比如“abc”字符串，“1”，“88”等数字。这些是真正的常量。再看一下`const`关键字。`const`只不过是让编译器将变量视为常量罢了，和真正的常量有本质上的区别。
2. **栈区**：函数的执行所需的空间，注意，当函数执行完毕，函数对应的栈内存全部销毁。
3. **堆区**：进程用来灵活分配内存的地方，只有手动释放时才会销毁内存。
4. **静态变量区**：用来存储静态变量与全局变量的区域

    - 静态变量：我们常常需要一些局部作用范围，生命周期却很长的变量
    - 全局变量：重要性就不必说了，在c语言程序中经常用到，但在C++中不推荐使用，因为会破坏封装性。

具体的存储方式如图所示：

![image](assets/image-20250701163946-37kihn7.png)


接下来用代码演示一下这几个区域。

堆区和栈区，是程序运行的主要地方。我们用一个最简单的程序来显示栈的用途。

**代码演示：**

至于堆区，主要意义在于灵活的生命周期，同样是刚才那个例子。

如果需要创建的对象有几十M，每次调用函数都需要创建一个这么大的对象，再复制到对应的容器中，那就太过耗费内存了。而且栈内存非常的小，通常不超过8M。

而使用堆内存，每调用一次函数就可以在堆内存中创建一个对象，容器中只要存储指针就可以了，极大的提高了程序效率。

**代码演示：**

而静态变量区：

有很多情况下，我们需要作用范围局限在函数之内，但生命周期却很长的变量，比如统计一个函数被调用的次数。

总结：栈区是函数执行的区域，堆区是函数内灵活分配内存的地方，二者缺一不可。

有很多人问为什么不能只在栈上运行程序，因为当函数运行结束时，栈是要销毁的，其上分配的内存全部失效。

也不能只在堆上运行程序，因为堆的唯一寻址方式就是指针，如果没有栈，根本无法使用堆。

提一下：栈区远远小于堆区，一般不超过8M，所以主要的内容都在对堆区上。堆区很大，虚拟内存剩下的都是堆区。

**注意：这节课对内存的划分比较粗糙，但新手理解到这里完全没有问题，这门课也够用了。**

程序执行的细节，还有剩下的区域是干什么的，我打算出一门叫做C++内存详解的课程，里面会详细讲解。包括pe文件头，内核区等。

# new关键字及内存泄露（*）